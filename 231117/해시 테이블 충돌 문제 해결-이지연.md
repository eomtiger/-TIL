### 해시 테이블에서 해시 값 충돌 문제를 해결하는 다양한 방법에 대해 말씀해 주세요.

1. **체이닝** : 연결리스트로 노드를 계속 추가해 나가는 방식 (제한 없이 계속 연결 가능, but 메모리 문제)
2. **Open Addressing** : 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용 (해당 키 값에 저장되어 있으면 다음 주소에 저장)
3. **선형 탐사** : 정해진 고정 폭으로 옮겨 해시값의 중복을 피함
4. **제곱 탐사** : 정해진 고정 폭을 제곱수로 옮겨 해시값의 중복을 피함

---

**[해시 테이블(Hash Table)과 시간 복잡도]**

해시 테이블은 **(Key, Value)로 데이터를 저장**하는 자료구조 중 하나로 **빠르게 데이터를 검색**할 수 있는 자료구조입니다.

빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문입니다.

각 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 **O(1)**의 시간 복잡도로 데이터를 조회합니다. 하지만 index값이 충돌이 발생한 경우 Chanining에 연결된 리스트들까지 검색해야 하므로 **O(N)**까지 증가할 수 있습니다.


**[해시 테이블 사용 이유]**

결국 데이터가 많아지면, 다른 데이터가 같은 해시 값으로 충돌 나는 현상이 발생하는데도 해시 테이블을 사용하는 이유는 적은 자원으로 많은 데이터를 효율적으로 관리하기 위함입니다.

하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능해집니다.

- 언제나 동일한 해시값 리턴, index를 알면 빠른 데이터 검색이 가능해짐
- 해시테이블의 시간복잡도 O(1) - (이진탐색트리는 O(logN))
