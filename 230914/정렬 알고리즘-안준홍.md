# 정렬 알고리즘
> 정렬 알고리즘에는 선택 정렬, 삽입 정렬, 버블 정렬, 병합 정렬, 힙 정렬, 퀵 정렬, 기수 정렬이 있습니다.

## 선택 정렬(Selection Sort)
> 데이터 중 가장 작은 값의 데이터를 선택하여 앞으로 보내는 정렬입니다.

**시간 복잡도**  
Average: O(N^2)  
Worst  : O(N^2)  
Best   : O(N^2)  

## 삽입 정렬(Insertion Sort)
> 데이터를 순서대로 뽑아 적절한 위치를 찾아 삽입하는 정렬입니다.
- 이미 정렬되어 있는 데이터가 많다면 빠른 알고리즘입니다.

**시간 복잡도**  
Average: O(N^2)  
Worst  : O(N^2)  
Best   : O(N)

## 버블 정렬(Bubble Sort)
> 옆에 있는 데이터와 비교하여 더 작은 값을 앞으로 보내는 정렬입니다.
- 정렬 알고리즘 중 가장 느리고 효율성이 떨어집니다.

**시간 복잡도**  
Average: O(N^2)  
Worst  : O(N^2)  
Best   : O(N^2)  

## 병합 정렬(Merge Sort)
> 분할 -> 정렬 -> 결합 순으로 진행되는 알고리즘으로, 데이터 배열을 2개 이상의 부분 배열로 분할하고 부분 배열에서 정렬한 뒤 결합하여 다시 정렬하는 알고리즘입니다.

**시간 복잡도**  
Average: O(N log N)  
Worst  : O(N log N)  
Best   : O(N log N)

## 힙 정렬(Heap Sort)
> 이진트리 기반의 트리형 자료구조로써 최솟값이나 최댓값을 찾아내기 위해서 사용합니다.
- 내림차순 정렬을 위해서는 최대 힙
- 오름차순 정렬을 위해서는 최소 힙

**시간 복잡도**  
Average: O(N log N)  
Worst  : O(N log N)  
Best   : O(N log N)

## 퀵 정렬(Quick Sort)
> 데이터 중 임의의 기준값(Pivot)을 정해서 두 부분 집합으로 나누고, 왼쪽은 피봇보다 작은 값, 오른쪽은 피봇보다 큰 값을 배치하고 더 이상 집합을 나눌 수 없을 때까지 재귀적으로 실행됩니다.
- 삽입 정렬과 반대로 이미 정렬된 데이터에 매우 비효율적입니다.

**시간 복잡도**  
Average: O(N log N)  
Worst  : O(N log N)  
Best   : O(N^2)

## 기수 정렬(Radix Sort)
> 낮은 자릿수부터 비교하여 완성하는 정렬입니다.
- 비교 연산을 하지 않으며, 정렬 속도가 빠른 편입니다.
- 데이터 전체 크기에 기수 테이블의 크기만큼 메모리가 더 필요하다는 단점이 있습니다.

**시간 복잡도**(d = 자릿수)  
Average: O(dN)  
Worst  : O(dN)  
Best   : O(dN)