# 부동소수점(Floating Point)
> 실수를 표현할 때 소수점의 위치를 고정하지 않는 것을 말합니다.  

```markdown
**7.625를 이진수로 표현하기**
- 정수 부분인 7의 경우 2^2 + 2^1 + 2^0 → 111로 표현 가능
- 소수 부분인 .625의 경우에는 2^-1 + 2^-3 → .101로 표현 가능
-> 따라서 111.101로 표현 가능
```

- 32bit(int) 기준 : 부호(1bit), 지수(8bit), 가수(23bit)
- 64bit(double) 기준 : 부호(1bit), 지수(11bit), 가수(52bit)

<br>

### int 표현
- 소수점이 없는, 정수 데이터를 저장하기 위한 자료형
- 32비트(4바이트)를 활용해서 숫자를 나타냄
- 첫번째 비트는 양수(0) 음수(1)의 부호를 나타내기위한 비트(Sign)
    - 0 0000000 00000000 00000000 00000000
- 나머지 31 비트는 해당 수의 절대값을 표현
- 이 두 부분의 조합으로 -(2^31) ~ -1 의 음수와 0 ~ (2^31) - 1의 양수를 표현할 수 있음
    - 0이 양수 표현에 포함되었기 때문에, 표현가능한 실제 양수의 값이 음수보다 하나 적다

<br>

### 실수 표현
- int 자료형과 마찬가지로, 첫 비트는 부호를 나타내기 위해 사용
- 이후 정수부와 소수부를 나타내기 위해서 크게 두가지 방법
    - 고정소수점(Fixed Point) 방식
        - 소수점의 위치를 미리 정해 고정하는 방식
        - 예) 7.625 라는 실수를 고정소수점 방식으로 표현하기
            - 7.625를 2진수로 변환하면 111.101
            - 부호비트를 양수(0)으로 두고 중앙의 소수점 위치를 기준으로 정수부와 소수부를 표현
            - 소수부는 앞에서부터 채우고, 남는 뒷자리는 0으로 채움
                
                ![스크린샷 2023-10-29 오후 10.45.04.png](https://github.com/junhong625/TIL/assets/83000975/d49bf0f4-c9a2-4e3f-be9b-9024f7a2a144)
                
        - 이러한 고정소수점 방식은 구현은 용이하지만, 비트 수 대비 표현 가능한 수의 범위가 적고, 또한 소수부를 표현하는 정밀도도 낮아지기 때문에, 높은 정밀도를 필요로 하지 않는 소규모 시스템에서나 쓸까말까한 방식
    - 부동소수점(Floating Point) 방식
        - 2진수로 변환하는 것 까지는 동일하지만, 정규화(Noramalizaition)를 통해 1.xxx * 2^n의 꼴로 변환 → 111.101의 예시에서는 소수점을 왼쪽으로 n=2만큼 이동시켜 1.11101 * 2^2를 만든다.
        - 이렇게 구한 1.11101과 n=2의 값을 이용해서 부동소수점 표현을 완성

<br>

---

### 참조
- [부동소수점 (+ 실수계산 오차가 생기는 이유)](https://www.youtube.com/watch?v=ZQDsWySjY6g)
- [컴퓨터에서의 실수 표현: 고정소수점 vs 부동소수점](https://gsmesie692.tistory.com/94)