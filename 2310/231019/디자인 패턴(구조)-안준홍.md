# 디자인 패턴
> 자주 사용하는 설계 형태를 정형화해서 이를 유형별로 템플릿을 만들어 둔것을 말합니다.
  
### 장점
- 개발자 간의 원활한 의사소통이 가능해집니다.
- 소프트웨어 구조 파악이 용이해집니다.
- 재사용을 통한 개발 시간 단축이 가능합니다.
- 설계 변경 요청에 대한 유연한 대처가 가능해집니다.
  
### 단점
- 객체지향 설계/구현 위주로 구조적 설계 구현에는 적합하지 않습니다.
- 디자인 패턴을 사용하지 않는 경우보다 초기 비용이 많이 듭니다.

<br>

## 구조 패턴
> 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는 데 많이 활용되는 패턴입니다.
- 클래스나 객체들의 구성을 통해 더 큰 구조로 만들 수 있게 해줍니다.
- 규모가 큰 시스템은 많은 클래스로 구성되어 복잡한 구조를 가지며 이로 인해 수정으로 인한 오류도 많이 발생할 수 있습니다.
- 이런 복잡한 형태의 구조를 갖는 시스템을 개발하기 쉽게 만들어주는 패턴이 바로 구조 패턴입니다.

### 종류
1. composite 패턴
- 사용자가 단일 객체와 복합 객체 모두 **동일하게 다루도록 한 것**입니다.
- 집합 속에 포함될 객체와 집합을 가지고 있는 객체, 이들 모두가 자기 자신과 동일한 타입의 객체 리스트를 가질 수 있오록 도와줍니다.
- 컴포지트 패턴을 사용하면, 기본 클래스와 이를 포함하는 컨테이너 클래스를 구분하지 않고 처리하는 **재귀적 합성**을 할 수 있습니다.
  
2. adapter 패턴
- 기존 클래스를 재사용할 수 있도록 **중간에서 맞춰주는 역할**을 합니다.
- 호환성이 없는 기존 클래스의 인터페이스를 변환해 재사용할 수 있도록 해줍니다.
- 레거시 시스템의 인터페이스를 다른 클래스의 요구에 맞게 변환해주는 것입니다.
- 클래스 adapter 패턴은 **상속**을 이용한 것이고, 인스턴스 adapter 패턴은 **위임**을 이용한 것입니다.
  
3. bridge 패턴
- **기능의 클래스 계층과 구현의 클래스 계층을 연결**하고 구현부에서 추상 계층을 분리하여 각자 독립적으로 변형할 수 있게 해줍니다.
- **구현과 인터페이스를 분리**할 수 있고, 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있습니다.
  
4. decorator 패턴
- 기존에 구현되어 있는 클래스에 **그때그때 필요한 기능을 추가**해 나가는 설계 패턴입니다.
- 기능 확장이 필요할 때 상속의 대안으로 사용합니다.
  
5. facade 패턴
- 서브시스템의 내부가 복잡하여 클라이언트 코드가 사용하기 힘들 때 사용합니다.
- 클라이언트 클래스와 서브시스템의 클라이언트 사이에 facade라는 객체를 세워놓음으로써 복잡한 관계를 정리(구조화)한 것입니다.
- 모든 관계가 **전면에 세워진 facade 객체를 통해서만 이루어**질 수 있게 **단순한 인터페이스를 제공**하는 것입니다.
- facade 패턴을 이용하면 facade에서 제공하는 단순화된 인터페이스만 사용하므로, 클래스 간의 의존 관계가 줄어들고 복잡성 또한 낮아지는 효과를 볼 수 있습니다.
  
6. flyweight 패턴
- **메모리 사용량을 줄이기 위한 패턴**으로 인스턴스를 필요한 대로 다 만들어 쓰지 말고, 동일한 것은 가능하면 공유해서 객체 생성을 줄이자는 것입니다.
  
7. proxy 패턴
- 일반적으로 프록시는 **다른 무언가와 이어지는 인터페이스의 역할**을 하는 클래스입니다.
- 프록시는 자신이 대변하는 객체와 그 객체에 접근하고자 하는 클라이언트 사이에서 여러 방식으로 작업을 처리합니다.

<br>

---

### 참조
- 박미진(컴퓨터 이론)