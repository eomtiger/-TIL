# MSA (MicroService Architecture)
각각을 마이크로하게 나눈 독립적인 서비스를 연결한 구조  
<br>

## MSA 장점
### 배포
- 서비스별 개별 배포가 가능합니다. (배포시 전체 서비스의 중단이 없습니다.)
- 특정 서비스의 요구사항만을 반영하여, 빠르게 배포 가능합니다.
 
### 확장
- 특정 서비스에 대한 확장성(scale-out)이 유리합니다.
- 클라우드 기반 서비스 사용에 적합합니다.
 
### 장애
- 일부 장애가 전체 서비스로 확장될 가능성이 적습니다.
- 부분적으로 발생하는 장애에 대한 격리가 수월합니다.
 
### 그 외
- 새로운 기술을 적용하기 유연합니다. (전체 서비스가 아닌 특정 서비스만 별도의 기술 또는 언어로 구현 가능)
- 각각의 서비스에 대한 구조 파악 및 분석이 모놀리식 구조에 비해 쉽습니다.  
<br>

## MSA 단점
### 설계의 어려움
- MSA는 모놀리식에 비해 상대적으로 많이 복잡하다.  
  서비스가 모두 분산되어 있기 때문에 개발자는 내부 시스템의 통신을 어떻게 가져가야 할지 정해야합니다.  
  또한, 통신의 장애와 서버의 부하 등이 있을 경우 어떻게 transaction을 유지할지 결정하고 구현해야합니다.
 
### 성능
- 서비스 간 호출 시 API를 사용하므로, 통신 비용이나 Latency에 대해 이슈가 존재합니다.
 
### 테스트/데이터 트랜잭션
- 모놀리식에서는 단일 트랜잭션을 유지하면 됐지만 MSA에서는 비즈니스에 대한 DB를 가지고 있는 서비스도 각기 다르고, 서비스의 연결을 위해서는 통신이 포함되기 때문에 트랜잭션을 유지하는게 어렵습니다.
- 통합 테스트가 어렵습니다. 개발 환경과 실제 운영환경을 동일하게 가져가는 것이 쉽지 않습니다.
 
### 데이터 관리
- 데이터가 여러 서비스에 분산되어 있어 조회하기 어렵습니다.
- 데이터를 관리하기 어렵습니다.  
<br>

## MSA 등장 배경
기존 모놀리식 구조 서비스의 한계점에서 MSA가 등장합니다.  

### 모놀리식 아키텍쳐(Monolithic Architecture)
소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어있는 형태  

한계점  
- 부분적인 장애가 전체 서비스 장애로 확대될 수 있다. (잘못된 코드 배포/갑작스런 트래픽 증가)
- 부분적인 Scale-out이 어렵다. (Scale-out : 여러 서버로 나누어 일을 처리하는 방식) (Monolithic Architecture에서는 사용되지 않는 다른 모든 서비스가 Scale-out되어야 하기 때문에 부분 Scale-out이 어렵다.)
- 여러 컴포넌트가 강하게 결합되어 있기 때문에 서비스의 변경이 어렵고, 수정 시 장애의 영향도 파악하기 힘들다.
- 배포 시간이 오래 걸린다. (규모가 커짐에 따라 작은 변경에도 높은 수준의 테스트 비용 발생)
- 한 Framework와 언어에 종속적이다.

<br>

## 참고
https://www.opsnow.com/%EC%9A%94%EC%A6%98-%EB%8C%80%EC%84%B8-msa/  
https://hahahoho5915.tistory.com/71  
https://velog.io/@whitebear/MSA  
