# 디자인 패턴
> 자주 사용하는 설계 형태를 정형화해서 이를 유형별로 템플릿을 만들어 둔것을 말합니다.
  
### 장점
- 개발자 간의 원활한 의사소통이 가능해집니다.
- 소프트웨어 구조 파악이 용이해집니다.
- 재사용을 통한 개발 시간 단축이 가능합니다.
- 설계 변경 요청에 대한 유연한 대처가 가능해집니다.
  
### 단점
- 객체지향 설계/구현 위주로 구조적 설계 구현에는 적합하지 않습니다.
- 디자인 패턴을 사용하지 않는 경우보다 초기 비용이 많이 듭니다.

<br>

## 행위 패턴
> 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의합니다.
- 여러 가지 행위 관련 패턴을 사용하여 독립적으로 일을 처리하고자 할 때 사용합니다.
- 행위 패턴은 메시지 교환과 관련된 것으로, 객체들 간의 행위나 알고리즘 등 관련된 패턴을 말합니다.

### 종류
1. iterator 패턴
- **반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근**할 수 있도록 iterator 객체 속에 넣은 다음, iterator 객체의 메서드를 이용해 자료구조를 활용할 수 있도록 해줍니다.
- 반복에 사용되는 자료구조에는 배열, 리스트, Set, Map 등이 있습니다.
- 어떤 데이터의 집합체라는 특징이 존재합니다.
  
2. observer 패턴
- 어떤 클래스에 **변화**가 일어났을 때, 이를 **감지**하여 다른 클래스에 **통보**해주는 패턴입니다.
- 어떤 일이 생기면 미리 등록한 객체들에게 상태 변화를 알려주는 역할을 합니다.
- 1대 다의 객체 의존관계를 정의한 것으로 한 객체가 상태를 변화시켰을 때 의존관계에 있는 다른 객체들에게 자동적으로 통지하고 변경시킵니다.
  
3. strategy 패턴
- 클라이언트와 무관하게 독립적으로 알고리즘을 변경할 수 있고, 클라이언트는 독립적으로 원하는 방식을 사용할 수 있습니다.
- 클라이언트에게 **알고리즘이 사용하는 데이터나 그 구조를 숨겨주는 역할**을 합니다.  
- 알고리즘을 사용하는 곳과 알고리즘을 제공하는 곳을 분리시킨 구조로 동적으로 교체할 수 있습니다.
  
4. template method 패턴
- 상위 클래스에서 추상적으로 표현하고 그 구체적인 내용을 하위 클래스에서 결정되는 디자인 패턴이 template method 패턴입니다.
- **하나의 틀에서 만들어진 것들은 형태가 다 같다.** 이런 틀 기능을 구현할 때 사용하는 패턴입니다.
- 이는 상속의 개념이 있는 상위 클래스와 하위 클래스의 구조에서 표현할 수 있습니다.
- 일반적으로 **상위 클래스(추상 클래스)**에는 **추상 메서드**를 통해 **기능의 골격을 제공**하고, **하위 클래스(구체 클래스)**의 메서드에서는 **세부 처리를 구체화**합니다.
- 상속의 개념처럼 코드 양을 줄이고 유지보수를 용이하게 만드는 역할을 합니다.
  
5. visitor 패턴
- 각 클래스의 데이터 구조로부터 **처리 기능을 분리**하여 별도의 visitor 클래스로 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 하는 것입니다.
- visitor 패턴을 이용해 특정 클래스의 데이터 구조와 내부를 돌아다니면서 수행하는 특정 작업을 분리할 수 있습니다.
- 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 많이 사용합니다.
  
6. chain of reponsibility 패턴
- **책임들이 연결**되어 있어 내가 책임을 못 질 것 같으면 **다음 책임자에게 자동으로 넘어가는 구조**를 말합니다.
- 소프트웨어 개발에서도 이렇게 자동으로 연결되는 구조로 프로그램을 만들면 유용합니다.
- 추상 클래스를 활용하여 설계합니다.
  
7. command 패턴
- **함수 오버로딩과 같은 추상화 개념**을 사용한 것입니다.
- 단순히 명령어를 추상 클래스와 구체 클래스로 분리하여 단순화한 것으로 끝나지 않고, 명령어에 따른 취소 기능까지도 포함합니다.
- 프로그램의 명령어를 구현할 때는 command 패턴을 활용할 수 있습니다.
  
8. mediator 패턴
- 객체지향 설계에서 객체의 수가 너무 많아지면 통신이 복잡해져 느슨한 결합의 특성을 해칠 수 있는데, 이를 해결하도록 **중간에 통제하고 지시할 수 있는 중재자를 두는 패턴**입니다.
- 중재자에게 모든 것을 요구하여 통신의 빈도를 줄이고 객체지향의 목표를 달성하게 해줍니다.
  
9. state 패턴
- **동일한 동작을 객체 상태에 따라 다르게 처리해야 할 때** 사용하는 패턴입니다.
- 상태와 각 상태 전이를 보다 명시적으로 나타냅니다.
- 특정 상태로 전이되는 것에 대해 각 상태 클래스마다 함수를 만들어주면 되므로 훨씬 유연하고 유지보수가 쉬운 구조를 만들 수 있습니다.
  
10. memento 패턴
- **undo 기능을 개발**할 때 쓸 수 있습니다.
- 클래스 설계 관점에서 **객체의 정보를 저장할 필요가 있을 때** 적용할 수 있습니다.
  
11. interpreter 패턴
- **무언가를 번역**하는데 사용합니다.
- 간단한 언어의 문법을 정의하고 해석하는데 사용합니다.
- 주로 SQL 언어나 통신 프로토콜 같은 것을 개발할 때 문법 규칙을 클래스호한 구조를 갖습니다.

<br>

---

### 참조
- 박미진(컴퓨터 이론)